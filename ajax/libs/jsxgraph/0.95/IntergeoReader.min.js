/* Version 0.95 */
/* Version 0.95 */
/*
    Copyright 2008-2012
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/
    JXG.IntergeoReader=new function(){this.board=null;this.objects={};this.readIntergeo=function(a,b){this.board=b;this.board.origin={};this.board.origin.usrCoords=[1,0,0];this.board.origin.scrCoords=[1,400,300];this.board.unitX=30;this.board.unitY=30;this.readElements(a.getElementsByTagName("elements"));this.readConstraints(a.getElementsByTagName("constraints"));this.cleanUp();this.board.fullUpdate();this.readDisplay(a.getElementsByTagName("display"));this.board.fullUpdate()};this.readElements=function(a){var b;for(var b=0;b<a[0].childNodes.length;b++){(function(c){var d;d=a[0].childNodes[c];if(d.nodeType>1){return}if(d.nodeName=="point"){JXG.IntergeoReader.storePoint(d)}else{if(d.nodeName=="line"||d.nodeName=="line_segment"||d.nodeName=="ray"||d.nodeName=="vector"){JXG.IntergeoReader.storeLine(d)}else{if(d.nodeName=="circle"){JXG.IntergeoReader.storeConic(d)}else{if(d.nodeName=="conic"){JXG.IntergeoReader.storeConic(d)}else{if(d.nodeName=="polygon"){}else{JXG.debug("Not implemented: "+d.nodeName+" "+d.getAttribute("id"))}}}}}})(b)}};this.addPointOld=function(d){var h=0,f=0,e=0,b,a=d.childNodes[h],k=[],g={strokeColor:"red",fillColor:"red",withLabel:true},m=[];while(a.nodeType>1){h++;a=d.childNodes[h]}g.name=d.getAttribute("id");if(a.nodeName=="homogeneous_coordinates"){for(f=0;f<a.childNodes.length;f++){if(a.childNodes[f].nodeType==1){if(a.childNodes[f].nodeName=="double"){k.push(a.childNodes[f].firstChild.data)}else{if(a.childNodes[f].nodeName=="complex"){for(e=0;e<a.childNodes[f].childNodes.length;e++){if(a.childNodes[f].childNodes[e].nodeName=="double"){k.push(a.childNodes[f].childNodes[e].firstChild.data)}}}else{JXG.debug("Not implemented: "+a.childNodes[f].nodeName);return}}}}for(f=0;f<k.length;f++){k[f]=parseFloat(k[f])}if(k.length==3){m=[k[2],k[0],k[1]]}else{if(k.length==6&&Math.abs(k[1])<1e-10&&Math.abs(k[3])<1e-10&&Math.abs(k[5])<1e-10){m=[k[4],k[0],k[2]]}else{JXG.debug("type not supported, yet");return}}}else{if(a.nodeName=="euclidean_coordinates"){for(f=0;f<a.childNodes.length;f++){if(a.childNodes[f].nodeType==1){k.push(a.childNodes[f].firstChild.data)}}for(f=0;f<k.length;f++){k[f]=parseFloat(k[f])}m=[k[0],k[1]]}else{if(a.nodeName=="polar_coordinates"){for(f=0;f<a.childNodes.length;f++){if(a.childNodes[f].nodeType==1){k.push(a.childNodes[f].firstChild.data)}}for(f=0;f<k.length;f++){k[f]=parseFloat(k[f])}m=[k[0]*Math.cos(k[1]),k[0]*Math.sin(k[1])]}else{JXG.debug("This coordinate type is not yet implemented: "+a.nodeName);return}}}b=this.board.create("point",m,g);this.objects[d.getAttribute("id")]=b};this.storePoint=function(f){var e=0,d=0,a=0,g=f.childNodes[e],h=[],b=[];while(g.nodeType>1){e++;g=f.childNodes[e]}if(g.nodeName=="homogeneous_coordinates"){for(d=0;d<g.childNodes.length;d++){if(g.childNodes[d].nodeType==1){if(g.childNodes[d].nodeName=="double"){h.push(g.childNodes[d].firstChild.data)}else{if(g.childNodes[d].nodeName=="complex"){for(a=0;a<g.childNodes[d].childNodes.length;a++){if(g.childNodes[d].childNodes[a].nodeName=="double"){h.push(g.childNodes[d].childNodes[a].firstChild.data)}}}else{JXG.debug("Not implemented: "+g.childNodes[d].nodeName);return}}}}for(d=0;d<h.length;d++){h[d]=parseFloat(h[d])}if(h.length==3){b=[h[2],h[0],h[1]]}else{if(h.length==6&&Math.abs(h[1])<1e-10&&Math.abs(h[3])<1e-10&&Math.abs(h[5])<1e-10){b=[h[4],h[0],h[2]]}else{JXG.debug("type not supported, yet");return}}}else{if(g.nodeName=="euclidean_coordinates"||g.nodeName=="euclidian_coordinates"){for(d=0;d<g.childNodes.length;d++){if(g.childNodes[d].nodeType==1){h.push(g.childNodes[d].firstChild.data)}}for(d=0;d<h.length;d++){h[d]=parseFloat(h[d])}b=[h[0],h[1]]}else{if(g.nodeName=="polar_coordinates"){for(d=0;d<g.childNodes.length;d++){if(g.childNodes[d].nodeType==1){h.push(g.childNodes[d].firstChild.data)}}for(d=0;d<h.length;d++){h[d]=parseFloat(h[d])}b=[h[0]*Math.cos(h[1]),h[0]*Math.sin(h[1])]}else{JXG.debug("This coordinate type is not yet implemented: "+g.nodeName);return}}}this.objects[f.getAttribute("id")]={id:f.getAttribute("id"),coords:null};this.objects[f.getAttribute("id")].coords=b;this.objects[f.getAttribute("id")].id=f.getAttribute("id");this.objects[f.getAttribute("id")].exists=false;this.objects[f.getAttribute("id")].i2geoType="point"};this.storeLine=function(d){var b,e,f,a;this.objects[d.getAttribute("id")]={id:d.getAttribute("id"),coords:null};b=0;e=d.childNodes[b];while(e.nodeType>1){b++;e=d.childNodes[b]}if(e.nodeName=="homogeneous_coordinates"){f=[];for(a=0;a<e.childNodes.length;a++){if(e.childNodes[a].nodeType==1){if(e.childNodes[a].nodeName=="double"){f.push(parseFloat(e.childNodes[a].firstChild.data))}else{}}}this.objects[d.getAttribute("id")].coords=f;this.objects[d.getAttribute("id")].id=d.getAttribute("id");this.objects[d.getAttribute("id")].exists=false;this.objects[d.getAttribute("id")].i2geoType="line"}};this.storeConic=function(d){var b,a,e,f;this.objects[d.getAttribute("id")]={id:d.getAttribute("id"),coords:null};b=0;e=d.childNodes[b];while(e.nodeType>1){b++;e=d.childNodes[b]}if(e.nodeName=="matrix"){f=[];for(a=0;a<e.childNodes.length;a++){if(e.childNodes[a].nodeType==1){if(e.childNodes[a].nodeName=="double"){f.push(parseFloat(e.childNodes[a].firstChild.data))}else{}}}this.objects[d.getAttribute("id")].coords=f;this.objects[d.getAttribute("id")].id=d.getAttribute("id");this.objects[d.getAttribute("id")].exists=false;this.objects[d.getAttribute("id")].i2geoType="conic"}};this.readConstraints=function(a){var b,c;this.board.options.point.strokeColor="blue";this.board.options.point.fillColor="blue";for(b=0;b<a[0].childNodes.length;b++){(function(d){var e;e=a[0].childNodes[d];if(e.nodeType>1){return}if(e.nodeName=="line_through_two_points"){JXG.IntergeoReader.addLineThroughTwoPoints(e,false)}else{if(e.nodeName=="ray_from_point_through_point"){JXG.IntergeoReader.addLineThroughTwoPoints(e,true)}else{if(e.nodeName=="line_through_point"){JXG.IntergeoReader.addLineThroughPoint(e)}else{if(e.nodeName=="line_parallel_to_line_through_point"){JXG.IntergeoReader.addLineParallelToLineThroughPoint(e,false)}else{if(e.nodeName=="ray_from_point_and_vector"){JXG.IntergeoReader.addLineParallelToLineThroughPoint(e,true)}else{if(e.nodeName=="line_perpendicular_to_line_through_point"){JXG.IntergeoReader.addLinePerpendicularToLineThroughPoint(e)}else{if(e.nodeName=="line_segment_by_points"){JXG.IntergeoReader.addLineSegmentByTwoPoints(e)}else{if(e.nodeName=="vector_from_point_to_point"){JXG.IntergeoReader.addVectorFromPointToPoint(e)}else{if(e.nodeName=="endpoints_of_line_segment"){JXG.IntergeoReader.addEndpointsOfLineSegment(e)}else{if(e.nodeName=="free_point"){}else{if(e.nodeName=="free_line"){JXG.IntergeoReader.addFreeLine(e)}else{if(e.nodeName=="point_on_line"){JXG.IntergeoReader.addPointOnLine(e)}else{if(e.nodeName=="point_on_line_segment"){JXG.IntergeoReader.addPointOnLine(e)}else{if(e.nodeName=="point_on_circle"){JXG.IntergeoReader.addPointOnCircle(e)}else{if(e.nodeName=="angular_bisector_of_three_points"){JXG.IntergeoReader.addAngularBisectorOfThreePoints(e,false)}else{if(e.nodeName=="angular_bisectors_of_two_lines"){JXG.IntergeoReader.addAngularBisectorsOfTwoLines(e,false)}else{if(e.nodeName=="line_angular_bisector_of_three_points"){JXG.IntergeoReader.addAngularBisectorOfThreePoints(e,true)}else{if(e.nodeName=="line_angular_bisectors_of_two_lines"){JXG.IntergeoReader.addAngularBisectorsOfTwoLines(e,true)}else{if(e.nodeName=="midpoint_of_two_points"){JXG.IntergeoReader.addMidpointOfTwoPoints(e)}else{if(e.nodeName=="midpoint"){JXG.IntergeoReader.addMidpointOfTwoPoints(e)}else{if(e.nodeName=="midpoint_of_line_segment"||e.nodeName=="midpoint_line_segment"){JXG.IntergeoReader.addMidpointOfLineSegment(e)}else{if(e.nodeName=="point_intersection_of_two_lines"){JXG.IntergeoReader.addPointIntersectionOfTwoLines(e)}else{if(e.nodeName=="locus_defined_by_point"){JXG.IntergeoReader.addLocusDefinedByPoint(e)}else{if(e.nodeName=="locus_defined_by_point_on_line"){JXG.IntergeoReader.addLocusDefinedByPointOnLine(e)}else{if(e.nodeName=="locus_defined_by_point_on_line_segment"){JXG.IntergeoReader.addLocusDefinedByPointOnLine(e)}else{if(e.nodeName=="locus_defined_by_line_through_point"){JXG.IntergeoReader.addLocusDefinedByLineThroughPoint(e)}else{if(e.nodeName=="locus_defined_by_point_on_circle"){JXG.IntergeoReader.addLocusDefinedByPointOnCircle(e)}else{if(e.nodeName=="circle_by_three_points"){JXG.IntergeoReader.addCircleByThreePoints(e)}else{if(e.nodeName=="circle_by_center_and_point"){JXG.IntergeoReader.addCircleByCenterAndPoint(e)}else{if(e.nodeName=="center_of_circle"){JXG.IntergeoReader.addCenterOfCircle(e)}else{if(e.nodeName=="intersection_points_of_two_circles"){JXG.IntergeoReader.addIntersectionPointsOfTwoCircles(e)}else{if(e.nodeName=="intersection_points_of_circle_and_line"){JXG.IntergeoReader.addIntersectionPointsOfCircleAndLine(e)}else{if(e.nodeName=="other_intersection_point_of_two_circles"){JXG.IntergeoReader.addOtherIntersectionPointOfTwoCircles(e)}else{if(e.nodeName=="other_intersection_point_of_circle_and_line"){JXG.IntergeoReader.addOtherIntersectionPointOfCircleAndLine(e)}else{if(e.nodeName=="circle_tangent_lines_by_point"){JXG.IntergeoReader.addCircleTangentLinesByPoint(e)}else{if(e.nodeName=="polygon_by_vertices"){JXG.IntergeoReader.addPolygonByVertices(e)}else{c=JXG.IntergeoReader.readParams(e);JXG.debug("readConstraints: not implemented: "+e.nodeName+": "+c[0])}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}})(b)}};this.setAttributes=function(a){a.setProperty({strokecolor:this.board.options.point.strokeColor,fillColor:this.board.options.point.fillColor})};this.readParams=function(b){var c=[],a;for(a=0;a<b.childNodes.length;a++){if(b.childNodes[a].nodeType==1){c.push(b.childNodes[a].firstChild.data)}}return c};this.addPoint=function(a){if(!a.exists){a.exists=true;a=this.board.create("point",a.coords,{name:a.id});a.setProperty({strokecolor:"red",fillColor:"red"})}return a};this.addLine=function(e){var a,d=this.objects[e].coords,b;for(a=0;a<d.length;a++){d[a]=parseFloat(d[a])}b=this.board.create("line",[d[2],d[0],d[1]],{name:e,strokeColor:"black",withLabel:true});this.objects[e]=b};this.addConic=function(a){var b;if(!a.exists){b=a.coords;a=this.board.create("conic",[b[0],b[4],b[8],b[1],b[5],b[2]],{name:a.id});a.exists=true}return a};this.cleanUp=function(){var a;for(a in this.objects){if(this.objects[a].exists==false){if(this.objects[a].i2geoType=="point"){this.addPoint(this.objects[a])}else{if(this.objects[a].i2geoType=="line"){this.addLine(this.objects[a])}else{if(this.objects[a].i2geoType=="conic"){this.addConic(this.objects[a])}else{JXG.debug("forgotten: "+this.objects[a].id+" of type "+this.objects[a].i2geoType)}}}}}};this.addLineThroughTwoPoints=function(d,e){var f=JXG.IntergeoReader.readParams(d),b,a,c;b=this.addPoint(this.objects[f[1]]);a=this.addPoint(this.objects[f[2]]);c=this.board.create("line",[b.id,a.id],{name:f[0],withLabel:true,straightFirst:!e,straightLast:true});this.objects[f[0]]=c;this.objects[f[0]].exists=true};this.addLineThroughPoint=function(d){var f=JXG.IntergeoReader.readParams(d),a,g=this.objects[f[0]].coords,e=this.addPoint(this.objects[f[1]]),b;for(a=0;a<g.length;a++){g[a]=parseFloat(g[a])}b=this.board.create("line",[function(){return g[2]-g[0]*e.X()-g[1]*e.Y()-g[2]*e.Z()},g[0],g[1]],{name:f[0],strokeColor:"black",withLabel:true});this.objects[f[0]]=b;this.objects[f[0]].exists=true};this.addLineParallelToLineThroughPoint=function(d,e){var f=JXG.IntergeoReader.readParams(d),b,a,c;b=this.addPoint(this.objects[f[1]]);a=this.addPoint(this.objects[f[2]]);c=this.board.create("parallel",[b.id,a.id],{name:f[0],withLabel:true,straightFirst:!e,straightLast:true});this.objects[f[0]]=c;this.objects[f[0]].exists=true};this.addLinePerpendicularToLineThroughPoint=function(d){var e=JXG.IntergeoReader.readParams(d),b,a,c;b=this.addPoint(this.objects[e[1]]);a=this.addPoint(this.objects[e[2]]);c=this.board.create("perpendicular",[b.id,a.id],{name:e[0],id:e[0],straightFirst:true,straightLast:true,point:{name:e[0]+"foot",id:e[0]+"foot"},withLabel:true});this.objects[e[0]]=c;this.objects[e[0]].exists=true};this.addLineSegmentByTwoPoints=function(d){var e=JXG.IntergeoReader.readParams(d),b,a,c;b=this.addPoint(this.objects[e[1]]);a=this.addPoint(this.objects[e[2]]);c=this.board.create("line",[b.id,a.id],{name:e[0],straightFirst:false,straightLast:false,strokeColor:"black",withLabel:true});this.objects[e[0]]=c;this.objects[e[0]].exists=true};this.addPointIntersectionOfTwoLines=function(c){var d=JXG.IntergeoReader.readParams(c),b=this.objects[d[1]],a=this.objects[d[2]];this.objects[d[0]]=this.board.create("intersection",[b,a,0],{name:d[0],id:d[0],withLabel:true});this.setAttributes(this.objects[d[0]]);this.objects[d[0]].exists=true};this.addFreeLine=function(g){var h=JXG.IntergeoReader.readParams(g),e=this.objects[h[0]].coords[0],d=this.objects[h[0]].coords[1],i=this.objects[h[0]].coords[2],f=this.board.create("line",[i,e,d],{name:h[0],id:h[0],withLabel:true});this.objects[h[0]]=f;this.objects[h[0]].exists=true};this.addPointOnLine=function(c){var d=JXG.IntergeoReader.readParams(c),a=JXG.getReference(this.board,d[1]),b;b=this.board.create("glider",[0,0,a],{name:d[0],id:d[0],withLabel:true});this.objects[d[0]].exists=true};this.addPointOnCircle=function(b){var d=JXG.IntergeoReader.readParams(b),e=JXG.getReference(this.board,d[1]),a;e.update();a=this.board.create("glider",[this.objects[d[0]].coords[1],this.objects[d[0]].coords[2],e],{name:d[0],id:d[0],withLabel:true});this.objects[d[0]].exists=true};this.addEndpointsOfLineSegment=function(b){var e=JXG.IntergeoReader.readParams(b),a=this.objects[e[2]],d=this.addPoint(this.objects[e[0]]),c=this.addPoint(this.objects[e[1]]);d.addConstraint([function(){return a.point1.Z()},function(){return a.point1.X()},function(){return a.point1.Y()}]);c.addConstraint([function(){return a.point2.Z()},function(){return a.point2.X()},function(){return a.point2.Y()}]);this.setAttributes(d);this.setAttributes(c)};this.addAngularBisectorOfThreePoints=function(f,b){var g=JXG.IntergeoReader.readParams(f),d,c,a,e;d=this.addPoint(this.objects[g[1]]);c=this.addPoint(this.objects[g[2]]);a=this.addPoint(this.objects[g[3]]);e=this.board.create("bisector",[d.id,c.id,a.id],{name:g[0],id:g[0],withLabel:true,straightFirst:b,straightLast:true,strokeColor:"#000000"});this.objects[g[0]]=e;this.objects[g[0]].exists=true};this.addMidpointOfTwoPoints=function(d){var e=JXG.IntergeoReader.readParams(d),b,a,c;b=this.addPoint(this.objects[e[1]]);a=this.addPoint(this.objects[e[2]]);c=this.board.create("midpoint",[b.id,a.id],{name:e[0]});this.setAttributes(c);this.objects[e[0]].exists=true};this.addMidpointOfLineSegment=function(b){var c=JXG.IntergeoReader.readParams(b),a=JXG.getReference(this.board,c[1]);el=this.board.create("midpoint",[a.point1,a.point2],{name:c[0]});this.setAttributes(el);this.objects[c[0]].exists=true};this.addCircleByThreePoints=function(c){var e=JXG.IntergeoReader.readParams(c),d=[],b,a;for(b=0;b<3;b++){d[b]=this.addPoint(this.objects[e[b+1]])}a=this.board.create("circumcircle",d,{name:e[0],id:e[0],point:{name:e[0]+"c",id:e[0]+"c"},withLabel:true});this.objects[e[0]].exists=true};this.addCenterOfCircle=function(b){var d=JXG.IntergeoReader.readParams(b),e=JXG.getReference(this.board,d[1]),a=this.board.create("point",[function(){return e.center.X()},function(){return e.center.Y()}],{name:d[0],id:d[0],withLabel:true});this.setAttributes(a);this.objects[d[0]].exists=true};this.addCircleTangentLinesByPoint=function(e){var d=JXG.IntergeoReader.readParams(e),k=JXG.getReference(this.board,d[2]),b=this.addPoint(this.objects[d[3]]),f,a,h,g,j,i;a=this.board.create("line",[function(){return JXG.Math.matVecMult(k.quadraticform,b.coords.usrCoords)[0]},function(){return JXG.Math.matVecMult(k.quadraticform,b.coords.usrCoords)[1]},function(){return JXG.Math.matVecMult(k.quadraticform,b.coords.usrCoords)[2]}],{visible:false});h=this.board.create("intersection",[k,a,0],{visible:false});g=this.board.create("intersection",[k,a,1],{visible:false});j=this.board.create("tangent",[h,k]);i=this.board.create("tangent",[g,k]);this.objects[d[0]]=j;this.objects[d[1]]=i;this.objects[d[0]].exists=true;this.objects[d[1]].exists=true};this.addIntersectionPointsOfTwoCircles=function(c){var f=JXG.IntergeoReader.readParams(c),b=JXG.getReference(this.board,f[2]),a=JXG.getReference(this.board,f[3]),e,d;e=this.board.create("intersection",[b,a,0],{name:f[0],id:f[0],withLabel:true});d=this.board.create("intersection",[b,a,1],{name:f[1],id:f[1],withLabel:true});this.setAttributes(e);this.setAttributes(d);this.objects[f[0]].exists=true;this.objects[f[1]].exists=true};this.addIntersectionPointsOfCircleAndLine=function(c){var f=JXG.IntergeoReader.readParams(c),b=JXG.getReference(this.board,f[2]),a=JXG.getReference(this.board,f[3]),e,d;e=this.board.create("intersection",[b,a,0],{name:f[0],id:f[0],withLabel:true});d=this.board.create("intersection",[b,a,1],{name:f[1],id:f[1],withLabel:true});this.setAttributes(e);this.setAttributes(d);this.objects[f[0]].exists=true;this.objects[f[1]].exists=true};this.addCircleByCenterAndPoint=function(c){var d=JXG.IntergeoReader.readParams(c),b=this.addPoint(this.objects[d[1]]),a=this.addPoint(this.objects[d[2]]);el=this.board.create("circle",[b.id,a.id],{name:d[0],id:d[0],withLabel:true});this.objects[d[0]].exists=true};this.addOtherIntersectionPointOfTwoCircles=function(c){var f=JXG.IntergeoReader.readParams(c),b=JXG.getReference(this.board,f[2]),a=JXG.getReference(this.board,f[3]),e=JXG.getReference(this.board,f[1]),d;d=this.board.create("otherintersection",[b,a,e],{name:f[0],id:f[0],withLabel:true});this.setAttributes(d);this.objects[f[0]].exists=true};this.addOtherIntersectionPointOfCircleAndLine=function(a){this.addOtherIntersectionPointOfTwoCircles(a)};this.addAngularBisectorsOfTwoLines=function(e,d){var f=JXG.IntergeoReader.readParams(e),b=this.objects[f[2]],a=this.objects[f[3]],c;c=this.board.create("bisectorlines",[b,a],{line1:{name:f[0],id:f[0],straightFirst:true,straightLast:true},line2:{name:f[1],id:f[1],straightFirst:true,straightLast:true},withLabel:true});this.objects[f[0]].exists=true;this.objects[f[1]].exists=true};this.addPolygonByVertices=function(c){var a,g,e=[],d=[],b,f=JXG.IntergeoReader.readParams(c);for(a=0;a<c.childNodes.length;a++){if(c.childNodes[a].nodeType==1){if(c.childNodes[a].nodeName=="list_of_vertices"){g=c.childNodes[a];e=JXG.IntergeoReader.readParams(g);break}}}for(a=0;a<e.length;a++){d.push(this.addPoint(this.objects[e[a]]))}b=this.board.create("polygon",d,{name:f[0],id:f[0],withLabel:true});this.objects[f[0]].exists=true};this.addVectorFromPointToPoint=function(c){var d=JXG.IntergeoReader.readParams(c),b,a;b=this.addPoint(this.objects[d[1]]);a=this.addPoint(this.objects[d[2]]);el=this.board.create("arrow",[b.id,a.id],{name:d[0]});this.setAttributes(el);this.objects[d[0]].exists=true};this.addLocusDefinedByPoint=function(b){var c=JXG.IntergeoReader.readParams(b),a=JXG.getReference(this.board,c[1]);a.setProperty({trace:true});this.objects[c[1]]=a;this.setAttributes(a)};this.addLocusDefinedByPointOnLine=function(b){var c=JXG.IntergeoReader.readParams(b),a=JXG.getReference(this.board,c[1]);a.setProperty({trace:true});this.objects[c[1]]=a;this.setAttributes(a)};this.addLocusDefinedByLineThroughPoint=function(b){var c=JXG.IntergeoReader.readParams(b),a=JXG.getReference(this.board,c[1]);a.setProperty({trace:true});this.objects[c[1]]=a;this.setAttributes(a)};this.addLocusDefinedByPointOnCircle=function(b){var c=JXG.IntergeoReader.readParams(b),a=JXG.getReference(this.board,c[1]);a.setProperty({trace:true});this.objects[c[1]]=a;this.setAttributes(a)};this.prepareString=function(b){var c=[],a;if(b.indexOf("<")!=0){for(a=0;a<b.length;a++){c[a]=JXG.Util.asciiCharCodeAt(b,a)}b=(new JXG.Util.Unzip(c)).unzipFile("construction/intergeo.xml")}return b};this.readDisplay=function(a){var c,b;if(!JXG.exists(a)||!JXG.isArray(a)){return}for(c=0;c<a[0].childNodes.length;c++){(function(g){var h,f,l={},e,k;h=a[0].childNodes[g];if(h.nodeType>1){return}if(h.nodeName=="background-color"){this.board.containerObj.style.backgroundColor=h.firstChild.data}else{if(h.nodeName=="style"){f=JXG.getReference(this.board,h.getAttribute("ref"));var i=[],d;for(d=0;d<h.childNodes.length;d++){if(h.childNodes[d].nodeType==1){e=h.childNodes[d].nodeName;k=h.childNodes[d].firstChild.data;if(e=="stroke"){e="strokeColor"}else{if(e=="stroke-width"||e=="border-width"){e="strokeWidth"}else{if(e=="fill"){e="fillColor"}else{if(e=="fill-opacity"){e="fillOpacity"}else{if(e=="border-opacity"){e="strokeOpacity"}else{if(e=="point-size"){e="size"}else{if(e=="label"){e="name"}else{if(e=="point-style"){e="face";if(k=="circle"){k="o"}else{if(k=="cross"){k="+"}else{if(k=="x-mark"){k="x"}else{if(k=="square"){k="[]"}else{if(k=="triangle"){k="triangleup"}else{if(k=="point"){k="o"}else{JXG.debug("Display: not implemented"+h.nodeName)}}}}}}}}}}}}}}l[e]=k}}f.setProperty(l)}else{JXG.debug("Display: not implemented"+h.nodeName)}}})(c)}}};